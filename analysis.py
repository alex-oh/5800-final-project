# -*- coding: utf-8 -*-
"""Analysis.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1mU40NTp96KDw0eNfxJmrGdPzpPWEN8QE
"""

import pandas as pd
import matplotlib.pyplot as plt
from google.colab import files
uploaded = files.upload()

df_recursive = pd.read_csv('df_recursive.csv')
df_iterative = pd.read_csv('df_iterative.csv')

df_recursive.head()

df_recursive.columns

df_iterative.head()

df_iterative.columns

import pandas as pd


# Extracting required columns
recursive_min_cash_flow = df_recursive['MinCashFlow']
iterative_edges = df_iterative['Edges']

# Comparing values and creating a new column in the output DataFrame
output = pd.DataFrame({
    'Transactions': df_recursive['Transactions'],
    'ComparisonResult': recursive_min_cash_flow.eq(iterative_edges)
})

# Renaming the ComparisonResult column to have True/False values
output['ComparisonResult'] = output['ComparisonResult'].replace({True: 'True', False: 'False'})

# Displaying the output DataFrame
output

# Filter rows where ComparisonResult is False
false_values = output[output['ComparisonResult'] == 'False']

# Print all rows where ComparisonResult is False
false_values

import matplotlib.pyplot as plt


# Extracting required columns
recursive_execution_time = df_recursive['ExecutionTime']
iterative_time_taken = df_iterative['TimeTaken']
transactions = range(1, min(len(df_recursive), len(df_iterative)) + 1)  # Assuming equal rows in both DataFrames

# Creating subplots for side-by-side comparison
fig, axs = plt.subplots(1, 2, figsize=(12, 4))

# Plotting the first graph (ExecutionTime)
axs[0].plot(transactions, recursive_execution_time, label='ExecutionTime (Recursive)', color='blue')
axs[0].set_xlabel('Transactions')
axs[0].set_ylabel('Time')
axs[0].set_title('ExecutionTime (Recursive)')
#axs[0].legend()
axs[0].grid(True)

# Plotting the second graph (TimeTaken)
axs[1].plot(transactions, iterative_time_taken, label='TimeTaken (Iterative)', color='orange')
axs[1].set_xlabel('Transactions')
axs[1].set_ylabel('Time')
axs[1].set_title('ExecutionTime (Iterative)')
#axs[1].legend()
axs[1].grid(True)

# Adjust layout for better visualization
plt.tight_layout()

# Show the plots
plt.show()

import matplotlib.pyplot as plt

# Summing the values of ExecutionTime and TimeTaken
sum_execution_time = df_recursive['ExecutionTime'].sum()
sum_time_taken = df_iterative['TimeTaken'].sum()

# Creating a bar plot to compare the summed values
plt.figure(figsize=(4, 4))

# Plotting the summed values
plt.bar(['Recursive', 'Iterative'], [sum_execution_time, sum_time_taken], color=['blue', 'green'])
plt.title('Comparison of ExecutionTime')
#plt.xlabel('Category')
plt.ylabel('Total Time Taken')

plt.show()

import matplotlib.pyplot as plt

# Assuming df_recursive and df_iterative are your DataFrames

# Extracting required columns
recursive_execution_time = df_recursive['ExecutionTime']
iterative_time_taken = df_iterative['TimeTaken']
transactions = range(1, min(len(df_recursive), len(df_iterative)) + 1)  # Assuming equal rows in both DataFrames

# Plotting the graph
plt.figure(figsize=(6, 3))
plt.plot(transactions, recursive_execution_time, label='ExecutionTime (Recursive)')
plt.plot(transactions, iterative_time_taken, label='TimeTaken (Iterative)')
plt.xlabel('Transactions')
plt.ylabel('Time')
plt.title('Comparison of ExecutionTime and TimeTaken')
plt.legend()
plt.grid(True)
plt.show()

import matplotlib.pyplot as plt

# Plotting the graph for df_recursive
plt.figure(figsize=(9, 5))

# Subplot 1 for df_recursive (MinCashFlow vs ExecutionTime)
plt.subplot(1, 2, 1)
plt.scatter(df_recursive['MinCashFlow'], df_recursive['ExecutionTime'], color='blue')
plt.title('df_recursive: MinCashFlow vs ExecutionTime')
plt.xlabel('MinCashFlow')
plt.ylabel('ExecutionTime')

# Plotting the graph for df_iterative
# Subplot 2 for df_iterative (Edges vs TimeTaken)
plt.subplot(1, 2, 2)
plt.scatter(df_iterative['Edges'], df_iterative['TimeTaken'], color='green')
plt.title('df_iterative: Edges vs TimeTaken')
plt.xlabel('Edges')
plt.ylabel('TimeTaken')

plt.tight_layout()
plt.show()

